---
title: "Subscriptions"
description: "Listen for real-time data changes across all connected clients"
---

Subscriptions are how you get live updates from Lark. You subscribe to a path, and your callback fires whenever the data at that path changes — no matter which client made the change.

## Event types

Lark supports five event types, each suited for different use cases.

| Event | When it fires |
|---|---|
| `value` | Fires with the entire snapshot whenever anything under the path changes. The simplest and most common event type. |
| `child_added` | Fires once for each existing child, then again whenever a new child is added. Includes a `prevChildKey` for sort ordering. |
| `child_changed` | Fires when an existing child's value changes. |
| `child_removed` | Fires when a child is removed from the path. |
| `child_moved` | Fires when a child's sort order changes (relevant with `orderBy` queries). |

`value` is all you need for most use cases. The child events are for working with large collections where you want granular control — adding, updating, and removing individual items without re-processing the entire list.

## How delta sync works

Lark doesn't re-send the entire dataset every time something changes. When you subscribe to a path, the server computes the minimal delta and sends only what changed. Your SDK assembles these deltas into full snapshots before calling your callbacks.

This means subscribing to a path with 10,000 children doesn't re-transmit all 10,000 children when one of them changes. The server sends a small delta describing the change, and your local SDK patches its cached copy.

You don't need to think about this — your callbacks always receive complete snapshots. But it's useful to know that Lark is efficient under the hood, especially for large datasets.

## Shared views

Multiple subscriptions to the same path and query share a single server-side view. If 100 clients subscribe to the same leaderboard with the same query, the server does the same work as it would for one subscription. The data is computed once and broadcast to all subscribers.

This is why Lark scales well for real-time features like leaderboards, live dashboards, and game state. The work is per unique query, not per subscriber.

<Note>
Shared views apply when the path and query are identical. Two subscriptions to the same path but with different `orderBy` or `limitTo` parameters create separate server-side views.
</Note>

## One-time reads vs. subscriptions

If you only need the current value and don't care about future changes, use a one-time read instead of a subscription. It fetches the data once and doesn't keep a live connection to that path.

One-time reads are useful for loading initial state, checking a value before writing, or fetching data that rarely changes.

## Next steps

<CardGroup cols={2}>
  <Card title="Lark SDK subscriptions" icon="code" href="/lark-sdk/subscriptions">
    Full API and code examples for real-time subscriptions in the Lark SDK.
  </Card>
  <Card title="REST API streaming" icon="globe" href="/rest-api/streaming">
    Subscribe to real-time updates over HTTP with Server-Sent Events.
  </Card>
</CardGroup>
