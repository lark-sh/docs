---
title: "Validation and limits"
description: "Size limits, key rules, and data validation constraints"
---

Lark enforces a set of constraints on keys, values, and write payloads. This page is a reference for all of them.

## Key rules

Keys are the path segments that identify children in the [JSON tree](/platform/data-structure). Every key must follow these rules:

| Constraint | Detail |
|-----------|--------|
| Max length | **768 UTF-8 bytes** |
| Forbidden characters | `.` `$` `#` `[` `]` `/` |
| Control characters | ASCII 0x00–0x1F and 0x7F are not allowed |
| Reserved prefix | Keys starting with `.` are reserved for Lark internal use |

The reserved `.` prefix is used by Lark for special system keys:

- `.priority` — Priority metadata for ordering
- `.value` — Used in conjunction with `.priority` to set both a value and a priority
- `.sv` — Server value placeholder (e.g., `{ ".sv": "timestamp" }`)

<Warning>
Characters like `.` and `$` are common in many systems (email addresses, MongoDB field names, template strings) but are forbidden in Lark keys. If you need to store an email as a key, encode it first — for example, replace `.` with `,` or use a hash.
</Warning>

## Value limits

| Constraint | Limit |
|-----------|-------|
| String value max size | **10 MB** |
| Total write payload max size | **16 MB** (JSON-encoded) |
| Volatile write max size | **2 KB** |

The write payload limit applies to the entire JSON body of a single write operation — including `set`, `update`, and `push`. If you're doing a multi-path update, the 16 MB limit covers all the paths combined.

Volatile writes are intentionally small. They're designed for high-frequency, fire-and-forget data like cursor positions and player movement — not for large payloads. See [volatile paths](/platform/volatile) for more detail.

<Note>
The 16 MB limit is on the JSON-encoded payload, not the in-memory size. JSON encoding adds overhead for keys, quotes, and structural characters, so the effective data limit is somewhat less than 16 MB.
</Note>

## Data types

Lark stores JSON. The supported value types are:

| Type | Example |
|------|---------|
| String | `"hello"` |
| Number | `42`, `3.14`, `-1` |
| Boolean | `true`, `false` |
| Object | `{ "key": "value" }` |
| Null | `null` (deletes the node) |

Writing `null` to a path deletes it. There's no separate "delete" wire operation — a null write and a remove are the same thing.

### A note on arrays

Lark doesn't have a native array type. If you write a JSON array, Lark converts it to an object with integer keys:

```typescript
// You write this:
await db.ref('items').set(['apple', 'banana', 'cherry']);

// Lark stores this:
// { "0": "apple", "1": "banana", "2": "cherry" }
```

This works, but it's fragile. If two clients modify the array at the same time, they'll overwrite each other's changes because they're both targeting the same integer keys. For lists that multiple clients might modify, use `push` to generate unique keys instead.

<Tip>
Prefer `push` over arrays for any list that grows over time or that multiple clients write to. Push keys are unique and chronologically sortable, so you get natural ordering without collision risk.
</Tip>

## Summary

Here's everything at a glance:

| Category | Rule | Limit |
|----------|------|-------|
| Key length | Max UTF-8 bytes | 768 |
| Key characters | Forbidden | `. $ # [ ] /` |
| Key characters | Forbidden | ASCII control chars (0x00–0x1F, 0x7F) |
| Key prefix | Reserved | `.` (system use) |
| String value | Max size | 10 MB |
| Write payload | Max size (JSON-encoded) | 16 MB |
| Volatile write | Max size | 2 KB |
| Data types | Supported | string, number, boolean, object, null |
| Arrays | Behavior | Converted to objects with integer keys |
